<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D SNAKE MULTIPLAYER - AI & TOUCH</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Assistant', sans-serif; touch-action: none; }
        canvas { display: block; }
        .ui-panel { position: fixed; z-index: 100; pointer-events: none; }
        .glass { background: rgba(15, 23, 42, 0.8); backdrop-filter: blur(12px); border: 1px solid rgba(255, 255, 255, 0.1); pointer-events: auto; }
        .speaking-indicator { width: 12px; height: 12px; border-radius: 50%; background: #4ade80; display: inline-block; margin-right: 5px; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.5); opacity: 0.5; } 100% { transform: scale(1); opacity: 1; } }
    </style>
</head>
<body>

    <!-- UI Overlay -->
    <div class="ui-panel top-4 right-4 glass p-4 rounded-xl text-white w-64">
        <h2 class="text-xl font-bold mb-2 text-blue-400 border-b border-slate-700 pb-1 text-center">שחקנים אונליין</h2>
        <div id="players-list" class="space-y-2 text-sm">
            <!-- שחקנים יתווספו כאן -->
        </div>
        <div class="mt-4 text-[10px] text-slate-400 text-center">
            השתמש ב-2 אצבעות לזום | החלק לסיבוב
        </div>
    </div>

    <div class="ui-panel bottom-4 right-4 flex gap-4">
        <button id="mic-toggle" class="glass p-4 rounded-full hover:bg-slate-700 transition-all shadow-lg">
            <svg id="mic-icon" xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
            </svg>
        </button>
    </div>

    <video id="hand-video" class="hidden" autoplay playsinline muted></video>
    <video id="webcam-preview" class="fixed bottom-4 left-4 w-40 h-32 rounded-xl border-2 border-blue-500 transform scaleX(-1) object-cover z-50" autoplay playsinline muted></video>

    <script type="importmap">
    {
        "imports": {
            "firebase/app": "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js",
            "firebase/auth": "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js",
            "firebase/firestore": "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
        }
    }
    </script>

    <script type="module">
        import { initializeApp } from "firebase/app";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "firebase/auth";
        import { getFirestore, doc, setDoc, onSnapshot, collection, deleteDoc, serverTimestamp } from "firebase/firestore";
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

        // --- Firebase Config ---
        const firebaseConfig = JSON.parse(__firebase_config);
        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'snake-3d-mp';

        let user = null;
        let handLandmarker;
        let isMicOn = false;
        let audioContext, analyser, dataArray;
        let gameStatePlayers = {};
        
        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x020617);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0x3b82f6, 1);
        dirLight.position.set(5, 15, 7);
        scene.add(dirLight);

        const grid = new THREE.GridHelper(100, 50, 0x1e293b, 0x0f172a);
        scene.add(grid);

        // --- Camera & Interaction State ---
        let camDistance = 25;
        let camRotationY = 0;
        let camRotationX = Math.PI / 4;
        let lastTouchDist = 0;
        let lastTouchPos = { x: 0, y: 0 };

        const playerMeshes = {};
        let mySnakeData = { body: [], color: Math.random() * 0xffffff };

        // --- Touch Event Listeners ---
        window.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
                lastTouchDist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
            } else if (e.touches.length === 1) {
                lastTouchPos = { x: e.touches[0].pageX, y: e.touches[0].pageY };
            }
        }, { passive: false });

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                const dist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                const delta = dist - lastTouchDist;
                camDistance = Math.max(5, Math.min(60, camDistance - delta * 0.1));
                lastTouchDist = dist;
            } else if (e.touches.length === 1) {
                const deltaX = e.touches[0].pageX - lastTouchPos.x;
                const deltaY = e.touches[0].pageY - lastTouchPos.y;
                camRotationY -= deltaX * 0.01;
                camRotationX = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camRotationX + deltaY * 0.01));
                lastTouchPos = { x: e.touches[0].pageX, y: e.touches[0].pageY };
            }
            e.preventDefault();
        }, { passive: false });

        // --- Firebase Auth & Sync ---
        async function initAuth() {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (err) { console.error("Auth error:", err); }

            onAuthStateChanged(auth, (u) => {
                user = u;
                if (user) setupSync();
            });
        }

        function setupSync() {
            const playersCol = collection(db, 'artifacts', appId, 'public', 'data', 'players');
            onSnapshot(playersCol, (snapshot) => {
                const currentUids = new Set();
                const updated = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    currentUids.add(data.uid);
                    updated[data.uid] = data;
                    updateSnakeMesh(data);
                });
                gameStatePlayers = updated;
                Object.keys(playerMeshes).forEach(uid => {
                    if (!currentUids.has(uid)) {
                        scene.remove(playerMeshes[uid].group);
                        delete playerMeshes[uid];
                    }
                });
                renderUI();
            }, err => console.error(err));

            window.addEventListener('beforeunload', async () => {
                if (user) await deleteDoc(doc(db, 'artifacts', appId, 'public', 'data', 'players', user.uid));
            });
        }

        function updateSnakeMesh(data) {
            if (!playerMeshes[data.uid]) {
                const group = new THREE.Group();
                playerMeshes[data.uid] = { group, segments: [] };
                scene.add(group);
            }
            const pInfo = playerMeshes[data.uid];
            const body = data.body || [];
            while (pInfo.segments.length < body.length) {
                const mesh = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.9, 0.9), new THREE.MeshPhongMaterial({ color: data.color || 0x3b82f6 }));
                pInfo.group.add(mesh);
                pInfo.segments.push(mesh);
            }
            while (pInfo.segments.length > body.length) { pInfo.group.remove(pInfo.segments.pop()); }
            body.forEach((pos, i) => {
                if (pInfo.segments[i]) {
                    pInfo.segments[i].position.set(pos.x, 0.45, pos.z);
                    if (data.isSpeaking) {
                        pInfo.segments[i].material.emissive.setHex(0x4ade80);
                        pInfo.segments[i].material.emissiveIntensity = 0.5;
                    } else {
                        pInfo.segments[i].material.emissive.setHex(0x000000);
                    }
                }
            });
        }

        // --- Logic & Loop ---
        async function initVision() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO", numHands: 1
            });
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            const video = document.getElementById('hand-video');
            const preview = document.getElementById('webcam-preview');
            video.srcObject = stream; preview.srcObject = stream;
            video.onloadedmetadata = () => { video.play(); requestAnimationFrame(gameLoop); };
        }

        let lastVideoTime = -1;
        function gameLoop() {
            const video = document.getElementById('hand-video');
            if (video.readyState >= 2 && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                try {
                    const detections = handLandmarker.detectForVideo(video, performance.now());
                    if (detections.landmarks && detections.landmarks.length > 0) {
                        const tip = detections.landmarks[0][8];
                        moveSnake((tip.x - 0.5) * -60, (tip.y - 0.5) * 60);
                    }
                } catch (e) {}
            }

            // Camera following with rotation & distance
            if (user && playerMeshes[user.uid]) {
                const head = playerMeshes[user.uid].segments[0];
                if (head) {
                    const offsetX = camDistance * Math.sin(camRotationY) * Math.cos(camRotationX);
                    const offsetY = camDistance * Math.sin(camRotationX);
                    const offsetZ = camDistance * Math.cos(camRotationY) * Math.cos(camRotationX);

                    const targetPos = new THREE.Vector3(
                        head.position.x + offsetX,
                        head.position.y + offsetY,
                        head.position.z + offsetZ
                    );
                    camera.position.lerp(targetPos, 0.1);
                    camera.lookAt(head.position);
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        async function moveSnake(tx, tz) {
            if (!user) return;
            mySnakeData.body.unshift({ x: tx, z: tz });
            if (mySnakeData.body.length > 25) mySnakeData.body.pop();
            let speaking = false;
            if (isMicOn && analyser) {
                analyser.getByteFrequencyData(dataArray);
                speaking = (dataArray.reduce((a, b) => a + b) / dataArray.length) > 35;
            }
            const myDoc = doc(db, 'artifacts', appId, 'public', 'data', 'players', user.uid);
            await setDoc(myDoc, { uid: user.uid, body: mySnakeData.body, color: mySnakeData.color, isSpeaking: speaking, lastSeen: serverTimestamp() }, { merge: true });
        }

        function setupMic() {
            const btn = document.getElementById('mic-toggle');
            const icon = document.getElementById('mic-icon');
            btn.onclick = async () => {
                if (!isMicOn) {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        audioContext = new AudioContext();
                        const source = audioContext.createMediaStreamSource(stream);
                        analyser = audioContext.createAnalyser();
                        dataArray = new Uint8Array(analyser.frequencyBinCount);
                        source.connect(analyser);
                        isMicOn = true;
                        icon.classList.replace('text-red-500', 'text-green-400');
                    } catch (e) { alert("גישה למיקרופון נדחתה."); }
                } else {
                    isMicOn = false;
                    icon.classList.replace('text-green-400', 'text-red-500');
                }
            };
        }

        function renderUI() {
            const list = document.getElementById('players-list');
            list.innerHTML = Object.keys(gameStatePlayers).map(uid => {
                const p = gameStatePlayers[uid];
                const isMe = uid === user?.uid;
                return `<div class="flex items-center justify-between p-2 rounded bg-slate-800/60 border border-slate-700/50">
                    <span class="${isMe ? 'text-blue-300 font-bold' : 'text-slate-200'}">${isMe ? '⭐ אני' : 'שחקן ' + uid.slice(0,4)}</span>
                    ${p.isSpeaking ? '<span class="speaking-indicator"></span>' : ''}
                </div>`;
            }).join('');
        }

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };

        initAuth(); initVision(); setupMic();
    </script>
</body>
</html>
